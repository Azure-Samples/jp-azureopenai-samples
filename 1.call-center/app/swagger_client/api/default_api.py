# coding: utf-8

"""
    Speech to Text API v3.0

    Speech to Text API v3.0.  # noqa: E501

    OpenAPI spec version: v3.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def copy_model_to_subscription(self, id, **kwargs):  # noqa: E501
        """Copy Model  # noqa: E501

        This method can be used to copy a model from one location to another. If the target subscription  key belongs to a subscription created for another location, the model will be copied to that location.  Only adapted models are allowed to copy to another subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_model_to_subscription(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model that will be copied. (required)
        :param ModelCopy model_copy: The body contains the subscription key of the target subscription.
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_model_to_subscription_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_model_to_subscription_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def copy_model_to_subscription_with_http_info(self, id, **kwargs):  # noqa: E501
        """Copy Model  # noqa: E501

        This method can be used to copy a model from one location to another. If the target subscription  key belongs to a subscription created for another location, the model will be copied to that location.  Only adapted models are allowed to copy to another subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_model_to_subscription_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model that will be copied. (required)
        :param ModelCopy model_copy: The body contains the subscription key of the target subscription.
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'model_copy']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_model_to_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `copy_model_to_subscription`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_copy' in params:
            body_params = params['model_copy']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/models/{id}/copyto', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Model',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dataset(self, **kwargs):  # noqa: E501
        """Create Dataset  # noqa: E501

        Uploads and creates a new dataset by getting the data from a specified URL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dataset(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Dataset dataset: Definition for the new dataset.
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_dataset_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_dataset_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_dataset_with_http_info(self, **kwargs):  # noqa: E501
        """Create Dataset  # noqa: E501

        Uploads and creates a new dataset by getting the data from a specified URL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dataset_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Dataset dataset: Definition for the new dataset.
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dataset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dataset" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dataset' in params:
            body_params = params['dataset']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/datasets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Dataset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_endpoint(self, **kwargs):  # noqa: E501
        """Create Endpoint  # noqa: E501

        Creates a new endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_endpoint(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Endpoint endpoint: The details of the endpoint.
        :return: Endpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_endpoint_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_endpoint_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_endpoint_with_http_info(self, **kwargs):  # noqa: E501
        """Create Endpoint  # noqa: E501

        Creates a new endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_endpoint_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Endpoint endpoint: The details of the endpoint.
        :return: Endpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['endpoint']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_endpoint" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'endpoint' in params:
            body_params = params['endpoint']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Endpoint',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_evaluation(self, **kwargs):  # noqa: E501
        """Create Evaluation  # noqa: E501

        Creates a new evaluation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_evaluation(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Evaluation evaluation: The details of the new evaluation.
        :return: Evaluation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_evaluation_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_evaluation_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_evaluation_with_http_info(self, **kwargs):  # noqa: E501
        """Create Evaluation  # noqa: E501

        Creates a new evaluation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_evaluation_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Evaluation evaluation: The details of the new evaluation.
        :return: Evaluation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['evaluation']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_evaluation" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'evaluation' in params:
            body_params = params['evaluation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/evaluations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Evaluation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_hook(self, **kwargs):  # noqa: E501
        """Create Web Hook  # noqa: E501

        If the property secret in the configuration is present and contains a non-empty string, it will be used to create a SHA256 hash of the payload with  the secret as HMAC key. This hash will be set as X-MicrosoftSpeechServices-Signature header when calling back into the registered URL.                When calling back into the registered URL, the request will contain a X-MicrosoftSpeechServices-Event header containing one of the registered event  types. There will be one request per registered event type.                After successfully registering the web hook, it will not be usable until a challenge/response is completed. To do this, a request with the event type  challenge will be made with a query parameter called validationToken. Respond to the challenge with a 200 OK containing the value of the validationToken  query parameter as the response body. When the challenge/response is successfully completed, the web hook will begin receiving events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_hook(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebHook web_hook: The details of the new web hook.
        :return: WebHook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_hook_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_hook_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_hook_with_http_info(self, **kwargs):  # noqa: E501
        """Create Web Hook  # noqa: E501

        If the property secret in the configuration is present and contains a non-empty string, it will be used to create a SHA256 hash of the payload with  the secret as HMAC key. This hash will be set as X-MicrosoftSpeechServices-Signature header when calling back into the registered URL.                When calling back into the registered URL, the request will contain a X-MicrosoftSpeechServices-Event header containing one of the registered event  types. There will be one request per registered event type.                After successfully registering the web hook, it will not be usable until a challenge/response is completed. To do this, a request with the event type  challenge will be made with a query parameter called validationToken. Respond to the challenge with a 200 OK containing the value of the validationToken  query parameter as the response body. When the challenge/response is successfully completed, the web hook will begin receiving events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_hook_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebHook web_hook: The details of the new web hook.
        :return: WebHook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_hook']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_hook" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_hook' in params:
            body_params = params['web_hook']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/webhooks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WebHook',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_model(self, **kwargs):  # noqa: E501
        """Create Model  # noqa: E501

        Creates a new model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_model(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Model model: The details of the new model.
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_model_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_model_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_model_with_http_info(self, **kwargs):  # noqa: E501
        """Create Model  # noqa: E501

        Creates a new model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_model_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Model model: The details of the new model.
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_model" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model' in params:
            body_params = params['model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/models', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Model',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_project(self, **kwargs):  # noqa: E501
        """Create Project  # noqa: E501

        Creates a new project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Project project: The details of the project.
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_project_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_project_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_project_with_http_info(self, **kwargs):  # noqa: E501
        """Create Project  # noqa: E501

        Creates a new project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Project project: The details of the project.
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project' in params:
            body_params = params['project']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Project',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_transcription(self, **kwargs):  # noqa: E501
        """Create Transcription  # noqa: E501

        Creates a new transcription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_transcription(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Transcription transcription: The details of the new transcription.
        :return: Transcription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_transcription_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_transcription_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_transcription_with_http_info(self, **kwargs):  # noqa: E501
        """Create Transcription  # noqa: E501

        Creates a new transcription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_transcription_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Transcription transcription: The details of the new transcription.
        :return: Transcription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transcription']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_transcription" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transcription' in params:
            body_params = params['transcription']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/transcriptions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transcription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_base_model_log(self, locale, log_id, **kwargs):  # noqa: E501
        """Delete Base Model Endpoint Log  # noqa: E501

        Deletes one audio or transcription log that have been stored when using the default base model of a given language.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_base_model_log(locale, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param str log_id: The identifier of the log. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_base_model_log_with_http_info(locale, log_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_base_model_log_with_http_info(locale, log_id, **kwargs)  # noqa: E501
            return data

    def delete_base_model_log_with_http_info(self, locale, log_id, **kwargs):  # noqa: E501
        """Delete Base Model Endpoint Log  # noqa: E501

        Deletes one audio or transcription log that have been stored when using the default base model of a given language.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_base_model_log_with_http_info(locale, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param str log_id: The identifier of the log. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['locale', 'log_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_base_model_log" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'locale' is set
        if self.api_client.client_side_validation and ('locale' not in params or
                                                       params['locale'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `locale` when calling `delete_base_model_log`")  # noqa: E501
        # verify the required parameter 'log_id' is set
        if self.api_client.client_side_validation and ('log_id' not in params or
                                                       params['log_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `log_id` when calling `delete_base_model_log`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'locale' in params:
            path_params['locale'] = params['locale']  # noqa: E501
        if 'log_id' in params:
            path_params['logId'] = params['log_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/base/{locale}/files/logs/{logId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_base_model_logs(self, locale, **kwargs):  # noqa: E501
        """Delete All Base Model Endpoint Logs  # noqa: E501

        Deletion process is done asynchronously and can take up to one day depending on the amount of log files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_base_model_logs(locale, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param str end_date: The end date of the audio logs deletion (specific day, UTC).              Expected format: \"yyyy-mm-dd\". for instance, \"2019-09-20\" results in deleting all logs on September 20h, 2019 and before.              Deletes all existing logs when date is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_base_model_logs_with_http_info(locale, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_base_model_logs_with_http_info(locale, **kwargs)  # noqa: E501
            return data

    def delete_base_model_logs_with_http_info(self, locale, **kwargs):  # noqa: E501
        """Delete All Base Model Endpoint Logs  # noqa: E501

        Deletion process is done asynchronously and can take up to one day depending on the amount of log files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_base_model_logs_with_http_info(locale, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param str end_date: The end date of the audio logs deletion (specific day, UTC).              Expected format: \"yyyy-mm-dd\". for instance, \"2019-09-20\" results in deleting all logs on September 20h, 2019 and before.              Deletes all existing logs when date is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['locale', 'end_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_base_model_logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'locale' is set
        if self.api_client.client_side_validation and ('locale' not in params or
                                                       params['locale'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `locale` when calling `delete_base_model_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'locale' in params:
            path_params['locale'] = params['locale']  # noqa: E501

        query_params = []
        if 'end_date' in params:
            query_params.append(('endDate', params['end_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/base/{locale}/files/logs', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dataset(self, id, **kwargs):  # noqa: E501
        """Delete Dataset  # noqa: E501

        Deletes the specified dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dataset(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dataset_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dataset_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_dataset_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Dataset  # noqa: E501

        Deletes the specified dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dataset_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_dataset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_endpoint(self, id, **kwargs):  # noqa: E501
        """Delete Endpoint  # noqa: E501

        Deletes the endpoint identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_endpoint(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_endpoint_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_endpoint_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_endpoint_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Endpoint  # noqa: E501

        Deletes the endpoint identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_endpoint_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_endpoint_log(self, id, log_id, **kwargs):  # noqa: E501
        """Delete Custom Model Endpoint Log  # noqa: E501

        Deletes one audio or transcription log that have been stored for a given endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_endpoint_log(id, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param str log_id: The identifier of the log. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_endpoint_log_with_http_info(id, log_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_endpoint_log_with_http_info(id, log_id, **kwargs)  # noqa: E501
            return data

    def delete_endpoint_log_with_http_info(self, id, log_id, **kwargs):  # noqa: E501
        """Delete Custom Model Endpoint Log  # noqa: E501

        Deletes one audio or transcription log that have been stored for a given endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_endpoint_log_with_http_info(id, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param str log_id: The identifier of the log. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'log_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_endpoint_log" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_endpoint_log`")  # noqa: E501
        # verify the required parameter 'log_id' is set
        if self.api_client.client_side_validation and ('log_id' not in params or
                                                       params['log_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `log_id` when calling `delete_endpoint_log`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'log_id' in params:
            path_params['logId'] = params['log_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{id}/files/logs/{logId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_endpoint_logs(self, id, **kwargs):  # noqa: E501
        """Delete All Custom Model Endpoint Logs  # noqa: E501

        The deletion process is done asynchronously and can take up to one day depending on the amount of log files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_endpoint_logs(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param str end_date: The end date of the audio logs deletion (specific day, UTC).              Expected format: \"yyyy-mm-dd\". for instance, \"2019-09-20\" results in deleting all logs on September 20h, 2019 and before.              Deletes all existing logs when date is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_endpoint_logs_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_endpoint_logs_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_endpoint_logs_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete All Custom Model Endpoint Logs  # noqa: E501

        The deletion process is done asynchronously and can take up to one day depending on the amount of log files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_endpoint_logs_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param str end_date: The end date of the audio logs deletion (specific day, UTC).              Expected format: \"yyyy-mm-dd\". for instance, \"2019-09-20\" results in deleting all logs on September 20h, 2019 and before.              Deletes all existing logs when date is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_endpoint_logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_endpoint_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end_date' in params:
            query_params.append(('endDate', params['end_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{id}/files/logs', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_evaluation(self, id, **kwargs):  # noqa: E501
        """Delete Evaluation  # noqa: E501

        Deletes the evaluation identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_evaluation(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_evaluation_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_evaluation_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_evaluation_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Evaluation  # noqa: E501

        Deletes the evaluation identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_evaluation_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_evaluation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_evaluation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/evaluations/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_hook(self, id, **kwargs):  # noqa: E501
        """Delete Web Hook  # noqa: E501

        Deletes the web hook registration identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_hook(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_hook_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_hook_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_hook_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Web Hook  # noqa: E501

        Deletes the web hook registration identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_hook_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_hook" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/webhooks/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model(self, id, **kwargs):  # noqa: E501
        """Delete Model  # noqa: E501

        Deletes the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_model_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_model_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_model_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Model  # noqa: E501

        Deletes the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/models/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_project(self, id, **kwargs):  # noqa: E501
        """Delete Project  # noqa: E501

        Deletes the project identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_project_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_project_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Project  # noqa: E501

        Deletes the project identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_transcription(self, id, **kwargs):  # noqa: E501
        """Delete Transcription  # noqa: E501

        Deletes the specified transcription task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_transcription(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_transcription_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_transcription_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_transcription_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Transcription  # noqa: E501

        Deletes the specified transcription task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_transcription_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_transcription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_transcription`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/transcriptions/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_base_model(self, id, **kwargs):  # noqa: E501
        """Get Base Model  # noqa: E501

        Gets the base model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_base_model(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the base model. (required)
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_base_model_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_base_model_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_base_model_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Base Model  # noqa: E501

        Gets the base model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_base_model_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the base model. (required)
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_base_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_base_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/models/base/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Model',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_base_model_log(self, locale, log_id, **kwargs):  # noqa: E501
        """Get Base Model Endpoint Log  # noqa: E501

        Gets a specific audio or transcription log for the default base model in a given language.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_base_model_log(locale, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param str log_id: The identifier of the log. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_base_model_log_with_http_info(locale, log_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_base_model_log_with_http_info(locale, log_id, **kwargs)  # noqa: E501
            return data

    def get_base_model_log_with_http_info(self, locale, log_id, **kwargs):  # noqa: E501
        """Get Base Model Endpoint Log  # noqa: E501

        Gets a specific audio or transcription log for the default base model in a given language.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_base_model_log_with_http_info(locale, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param str log_id: The identifier of the log. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['locale', 'log_id', 'sas_validity_in_seconds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_base_model_log" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'locale' is set
        if self.api_client.client_side_validation and ('locale' not in params or
                                                       params['locale'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `locale` when calling `get_base_model_log`")  # noqa: E501
        # verify the required parameter 'log_id' is set
        if self.api_client.client_side_validation and ('log_id' not in params or
                                                       params['log_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `log_id` when calling `get_base_model_log`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'locale' in params:
            path_params['locale'] = params['locale']  # noqa: E501
        if 'log_id' in params:
            path_params['logId'] = params['log_id']  # noqa: E501

        query_params = []
        if 'sas_validity_in_seconds' in params:
            query_params.append(('sasValidityInSeconds', params['sas_validity_in_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/base/{locale}/files/logs/{logId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='File',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_base_model_logs(self, locale, **kwargs):  # noqa: E501
        """Get Base Model Endpoint Logs  # noqa: E501

        Gets the list of audio and transcription logs that have been stored when using the default base model of a given language.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_base_model_logs(locale, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :param str skip_token: Token to skip logs that were already retrieved in previous requests. Pagination starts from beginning when not defined.
        :param int top: Format - int32. Number of files that will be included (between 1 and 5000).
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_base_model_logs_with_http_info(locale, **kwargs)  # noqa: E501
        else:
            (data) = self.get_base_model_logs_with_http_info(locale, **kwargs)  # noqa: E501
            return data

    def get_base_model_logs_with_http_info(self, locale, **kwargs):  # noqa: E501
        """Get Base Model Endpoint Logs  # noqa: E501

        Gets the list of audio and transcription logs that have been stored when using the default base model of a given language.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_base_model_logs_with_http_info(locale, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :param str skip_token: Token to skip logs that were already retrieved in previous requests. Pagination starts from beginning when not defined.
        :param int top: Format - int32. Number of files that will be included (between 1 and 5000).
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['locale', 'sas_validity_in_seconds', 'skip_token', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_base_model_logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'locale' is set
        if self.api_client.client_side_validation and ('locale' not in params or
                                                       params['locale'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `locale` when calling `get_base_model_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'locale' in params:
            path_params['locale'] = params['locale']  # noqa: E501

        query_params = []
        if 'sas_validity_in_seconds' in params:
            query_params.append(('sasValidityInSeconds', params['sas_validity_in_seconds']))  # noqa: E501
        if 'skip_token' in params:
            query_params.append(('skipToken', params['skip_token']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/base/{locale}/files/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedFiles',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_base_model_manifest(self, id, **kwargs):  # noqa: E501
        """Get Base Model Manifest  # noqa: E501

        Returns an manifest for this base model which can be used in an on-premise container.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_base_model_manifest(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The ID of the model to generate a manifest for. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: ModelManifest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_base_model_manifest_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_base_model_manifest_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_base_model_manifest_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Base Model Manifest  # noqa: E501

        Returns an manifest for this base model which can be used in an on-premise container.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_base_model_manifest_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The ID of the model to generate a manifest for. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: ModelManifest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sas_validity_in_seconds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_base_model_manifest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_base_model_manifest`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sas_validity_in_seconds' in params:
            query_params.append(('sasValidityInSeconds', params['sas_validity_in_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/models/base/{id}/manifest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelManifest',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_base_models(self, **kwargs):  # noqa: E501
        """Get Base Models  # noqa: E501

        Gets the list of base models for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_base_models(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of base models that will be skipped.
        :param int top: Format - int32. Number of base models that will be included after skipping.
        :return: PaginatedModels
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_base_models_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_base_models_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_base_models_with_http_info(self, **kwargs):  # noqa: E501
        """Get Base Models  # noqa: E501

        Gets the list of base models for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_base_models_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of base models that will be skipped.
        :param int top: Format - int32. Number of base models that will be included after skipping.
        :return: PaginatedModels
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_base_models" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/models/base', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedModels',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dataset(self, id, **kwargs):  # noqa: E501
        """Get Dataset  # noqa: E501

        Gets the dataset identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dataset_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dataset_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_dataset_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Dataset  # noqa: E501

        Gets the dataset identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_dataset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Dataset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dataset_file(self, id, file_id, **kwargs):  # noqa: E501
        """Get Dataset File  # noqa: E501

        Gets one specific file (identified with fileId) from a dataset (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_file(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dataset_file_with_http_info(id, file_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dataset_file_with_http_info(id, file_id, **kwargs)  # noqa: E501
            return data

    def get_dataset_file_with_http_info(self, id, file_id, **kwargs):  # noqa: E501
        """Get Dataset File  # noqa: E501

        Gets one specific file (identified with fileId) from a dataset (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_file_with_http_info(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'file_id', 'sas_validity_in_seconds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_dataset_file`")  # noqa: E501
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and ('file_id' not in params or
                                                       params['file_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_id` when calling `get_dataset_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'file_id' in params:
            path_params['fileId'] = params['file_id']  # noqa: E501

        query_params = []
        if 'sas_validity_in_seconds' in params:
            query_params.append(('sasValidityInSeconds', params['sas_validity_in_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/files/{fileId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='File',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dataset_files(self, id, **kwargs):  # noqa: E501
        """Get Dataset Files  # noqa: E501

        Gets the files of the dataset identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_files(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :param int skip: Format - int32. Number of files that will be skipped.
        :param int top: Format - int32. Number of files that will be included after skipping.
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dataset_files_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dataset_files_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_dataset_files_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Dataset Files  # noqa: E501

        Gets the files of the dataset identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_files_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :param int skip: Format - int32. Number of files that will be skipped.
        :param int top: Format - int32. Number of files that will be included after skipping.
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sas_validity_in_seconds', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_files" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_dataset_files`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sas_validity_in_seconds' in params:
            query_params.append(('sasValidityInSeconds', params['sas_validity_in_seconds']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedFiles',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_datasets(self, **kwargs):  # noqa: E501
        """Get Datasets  # noqa: E501

        Gets a list of datasets for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :return: PaginatedDatasets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_datasets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_datasets_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_datasets_with_http_info(self, **kwargs):  # noqa: E501
        """Get Datasets  # noqa: E501

        Gets a list of datasets for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :return: PaginatedDatasets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_datasets" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/datasets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedDatasets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_datasets_for_project(self, id, **kwargs):  # noqa: E501
        """Get Datasets for Project  # noqa: E501

        Gets the list of datasets for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasets_for_project(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :return: PaginatedDatasets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_datasets_for_project_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_datasets_for_project_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_datasets_for_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Datasets for Project  # noqa: E501

        Gets the list of datasets for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasets_for_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :return: PaginatedDatasets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_datasets_for_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_datasets_for_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}/datasets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedDatasets',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_endpoint(self, id, **kwargs):  # noqa: E501
        """Get Endpoint  # noqa: E501

        Gets the endpoint identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_endpoint(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :return: Endpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_endpoint_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_endpoint_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_endpoint_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Endpoint  # noqa: E501

        Gets the endpoint identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_endpoint_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :return: Endpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Endpoint',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_endpoint_log(self, id, log_id, **kwargs):  # noqa: E501
        """Get Custom Model Endpoint Log  # noqa: E501

        Gets a specific audio or transcription log for a given endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_endpoint_log(id, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param str log_id: The identifier of the log. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_endpoint_log_with_http_info(id, log_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_endpoint_log_with_http_info(id, log_id, **kwargs)  # noqa: E501
            return data

    def get_endpoint_log_with_http_info(self, id, log_id, **kwargs):  # noqa: E501
        """Get Custom Model Endpoint Log  # noqa: E501

        Gets a specific audio or transcription log for a given endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_endpoint_log_with_http_info(id, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param str log_id: The identifier of the log. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'log_id', 'sas_validity_in_seconds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_endpoint_log" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_endpoint_log`")  # noqa: E501
        # verify the required parameter 'log_id' is set
        if self.api_client.client_side_validation and ('log_id' not in params or
                                                       params['log_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `log_id` when calling `get_endpoint_log`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'log_id' in params:
            path_params['logId'] = params['log_id']  # noqa: E501

        query_params = []
        if 'sas_validity_in_seconds' in params:
            query_params.append(('sasValidityInSeconds', params['sas_validity_in_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{id}/files/logs/{logId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='File',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_endpoint_logs(self, id, **kwargs):  # noqa: E501
        """Get Custom Model Endpoint Logs  # noqa: E501

        Gets the list of audio and transcription logs that have been stored for a given endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_endpoint_logs(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :param str skip_token: Token to skip logs that were already retrieved in previous requests. Pagination starts from beginning when not defined.
        :param int top: Format - int32. Number of files that will be included (between 1 and 5000).
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_endpoint_logs_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_endpoint_logs_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_endpoint_logs_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Custom Model Endpoint Logs  # noqa: E501

        Gets the list of audio and transcription logs that have been stored for a given endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_endpoint_logs_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :param str skip_token: Token to skip logs that were already retrieved in previous requests. Pagination starts from beginning when not defined.
        :param int top: Format - int32. Number of files that will be included (between 1 and 5000).
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sas_validity_in_seconds', 'skip_token', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_endpoint_logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_endpoint_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sas_validity_in_seconds' in params:
            query_params.append(('sasValidityInSeconds', params['sas_validity_in_seconds']))  # noqa: E501
        if 'skip_token' in params:
            query_params.append(('skipToken', params['skip_token']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{id}/files/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedFiles',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_endpoints(self, **kwargs):  # noqa: E501
        """Get Endpoints  # noqa: E501

        Gets the list of endpoints for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_endpoints(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of endpoints that will be skipped.
        :param int top: Format - int32. Number of endpoints that will be included after skipping.
        :return: PaginatedEndpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_endpoints_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_endpoints_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_endpoints_with_http_info(self, **kwargs):  # noqa: E501
        """Get Endpoints  # noqa: E501

        Gets the list of endpoints for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_endpoints_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of endpoints that will be skipped.
        :param int top: Format - int32. Number of endpoints that will be included after skipping.
        :return: PaginatedEndpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_endpoints" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedEndpoints',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_endpoints_for_project(self, id, **kwargs):  # noqa: E501
        """Get Endpoints for Project  # noqa: E501

        Gets the list of endpoints for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_endpoints_for_project(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of endpoints that will be skipped.
        :param int top: Format - int32. Number of endpoints that will be included after skipping.
        :return: PaginatedEndpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_endpoints_for_project_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_endpoints_for_project_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_endpoints_for_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Endpoints for Project  # noqa: E501

        Gets the list of endpoints for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_endpoints_for_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of endpoints that will be skipped.
        :param int top: Format - int32. Number of endpoints that will be included after skipping.
        :return: PaginatedEndpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_endpoints_for_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_endpoints_for_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}/endpoints', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedEndpoints',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_evaluation(self, id, **kwargs):  # noqa: E501
        """Get Evaluation  # noqa: E501

        Gets the evaluation identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_evaluation(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :return: Evaluation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_evaluation_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_evaluation_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_evaluation_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Evaluation  # noqa: E501

        Gets the evaluation identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_evaluation_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :return: Evaluation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_evaluation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_evaluation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/evaluations/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Evaluation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_evaluation_file(self, id, file_id, **kwargs):  # noqa: E501
        """Get Evaluation File  # noqa: E501

        Gets one specific file (identified with fileId) from an evaluation (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_evaluation_file(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_evaluation_file_with_http_info(id, file_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_evaluation_file_with_http_info(id, file_id, **kwargs)  # noqa: E501
            return data

    def get_evaluation_file_with_http_info(self, id, file_id, **kwargs):  # noqa: E501
        """Get Evaluation File  # noqa: E501

        Gets one specific file (identified with fileId) from an evaluation (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_evaluation_file_with_http_info(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'file_id', 'sas_validity_in_seconds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_evaluation_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_evaluation_file`")  # noqa: E501
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and ('file_id' not in params or
                                                       params['file_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_id` when calling `get_evaluation_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'file_id' in params:
            path_params['fileId'] = params['file_id']  # noqa: E501

        query_params = []
        if 'sas_validity_in_seconds' in params:
            query_params.append(('sasValidityInSeconds', params['sas_validity_in_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/evaluations/{id}/files/{fileId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='File',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_evaluation_files(self, id, **kwargs):  # noqa: E501
        """Get Evaluation Files  # noqa: E501

        Gets the files of the evaluation identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_evaluation_files(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :param int skip: Format - int32. Number of files that will be skipped.
        :param int top: Format - int32. Number of files that will be included after skipping.
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_evaluation_files_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_evaluation_files_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_evaluation_files_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Evaluation Files  # noqa: E501

        Gets the files of the evaluation identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_evaluation_files_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :param int skip: Format - int32. Number of files that will be skipped.
        :param int top: Format - int32. Number of files that will be included after skipping.
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sas_validity_in_seconds', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_evaluation_files" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_evaluation_files`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sas_validity_in_seconds' in params:
            query_params.append(('sasValidityInSeconds', params['sas_validity_in_seconds']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/evaluations/{id}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedFiles',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_evaluations(self, **kwargs):  # noqa: E501
        """Get Evaluations  # noqa: E501

        Gets the list of evaluations for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_evaluations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of evaluations that will be skipped.
        :param int top: Format - int32. Number of evaluations that will be included after skipping.
        :return: PaginatedEvaluations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_evaluations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_evaluations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_evaluations_with_http_info(self, **kwargs):  # noqa: E501
        """Get Evaluations  # noqa: E501

        Gets the list of evaluations for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_evaluations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of evaluations that will be skipped.
        :param int top: Format - int32. Number of evaluations that will be included after skipping.
        :return: PaginatedEvaluations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_evaluations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/evaluations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedEvaluations',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_evaluations_for_project(self, id, **kwargs):  # noqa: E501
        """Get Evaluations for Project  # noqa: E501

        Gets the list of evaluations for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_evaluations_for_project(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of evaluations that will be skipped.
        :param int top: Format - int32. Number of evaluations that will be included after skipping.
        :return: PaginatedEvaluations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_evaluations_for_project_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_evaluations_for_project_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_evaluations_for_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Evaluations for Project  # noqa: E501

        Gets the list of evaluations for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_evaluations_for_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of evaluations that will be skipped.
        :param int top: Format - int32. Number of evaluations that will be included after skipping.
        :return: PaginatedEvaluations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_evaluations_for_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_evaluations_for_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}/evaluations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedEvaluations',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_health_status(self, **kwargs):  # noqa: E501
        """Get Health Status  # noqa: E501

        Returns the overall health of the service and optionally of the different subcomponents.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_health_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: HealthStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_health_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_health_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_health_status_with_http_info(self, **kwargs):  # noqa: E501
        """Get Health Status  # noqa: E501

        Returns the overall health of the service and optionally of the different subcomponents.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_health_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: HealthStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_health_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/healthstatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HealthStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_hook(self, id, **kwargs):  # noqa: E501
        """Get Web Hook  # noqa: E501

        Gets the web hook registration identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hook(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook. (required)
        :return: WebHook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_hook_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_hook_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_hook_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Web Hook  # noqa: E501

        Gets the web hook registration identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hook_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook. (required)
        :return: WebHook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_hook" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/webhooks/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WebHook',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_hooks(self, **kwargs):  # noqa: E501
        """Get Web Hooks  # noqa: E501

        Gets the list of web hook registrations for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hooks(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of hooks that will be skipped.
        :param int top: Format - int32. Number of hooks that will be included after skipping.
        :return: PaginatedWebHooks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_hooks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_hooks_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_hooks_with_http_info(self, **kwargs):  # noqa: E501
        """Get Web Hooks  # noqa: E501

        Gets the list of web hook registrations for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hooks_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of hooks that will be skipped.
        :param int top: Format - int32. Number of hooks that will be included after skipping.
        :return: PaginatedWebHooks
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_hooks" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/webhooks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedWebHooks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model(self, id, **kwargs):  # noqa: E501
        """Get Model  # noqa: E501

        Gets the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_model_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Model  # noqa: E501

        Gets the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/models/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Model',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_manifest(self, id, **kwargs):  # noqa: E501
        """Get Custom Model Manifest  # noqa: E501

        Returns an manifest for this model which can be used in an on-premise container.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_manifest(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The ID of the model to generate a manifest for. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: ModelManifest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_manifest_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_manifest_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_model_manifest_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Custom Model Manifest  # noqa: E501

        Returns an manifest for this model which can be used in an on-premise container.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_manifest_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The ID of the model to generate a manifest for. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: ModelManifest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sas_validity_in_seconds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_manifest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_model_manifest`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sas_validity_in_seconds' in params:
            query_params.append(('sasValidityInSeconds', params['sas_validity_in_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/models/{id}/manifest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelManifest',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_models(self, **kwargs):  # noqa: E501
        """Get Custom Models  # noqa: E501

        Gets the list of custom models for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_models(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of models that will be skipped.
        :param int top: Format - int32. Number of models that will be included after skipping.
        :return: PaginatedModels
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_models_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_models_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_models_with_http_info(self, **kwargs):  # noqa: E501
        """Get Custom Models  # noqa: E501

        Gets the list of custom models for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_models_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of models that will be skipped.
        :param int top: Format - int32. Number of models that will be included after skipping.
        :return: PaginatedModels
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_models" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/models', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedModels',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_models_for_project(self, id, **kwargs):  # noqa: E501
        """Get Models for Project  # noqa: E501

        Gets the list of models for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_models_for_project(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of models that will be skipped.
        :param int top: Format - int32. Number of models that will be included after skipping.
        :return: PaginatedModels
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_models_for_project_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_models_for_project_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_models_for_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Models for Project  # noqa: E501

        Gets the list of models for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_models_for_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of models that will be skipped.
        :param int top: Format - int32. Number of models that will be included after skipping.
        :return: PaginatedModels
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_models_for_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_models_for_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}/models', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedModels',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project(self, id, **kwargs):  # noqa: E501
        """Get Project  # noqa: E501

        Gets the project identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_project_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_project_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Project  # noqa: E501

        Gets the project identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Project',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_projects(self, **kwargs):  # noqa: E501
        """Get Projects  # noqa: E501

        Gets the list of projects for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_projects(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of projects that will be skipped.
        :param int top: Format - int32. Number of projects that will be included after skipping.
        :return: PaginatedProjects
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_projects_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_projects_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_projects_with_http_info(self, **kwargs):  # noqa: E501
        """Get Projects  # noqa: E501

        Gets the list of projects for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_projects_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of projects that will be skipped.
        :param int top: Format - int32. Number of projects that will be included after skipping.
        :return: PaginatedProjects
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_projects" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedProjects',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_supported_locales_for_datasets(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Datasets  # noqa: E501

        Gets a list of supported locales for data imports.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_supported_locales_for_datasets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiSpeechtotextV30DatasetsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_supported_locales_for_datasets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_supported_locales_for_datasets_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_supported_locales_for_datasets_with_http_info(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Datasets  # noqa: E501

        Gets a list of supported locales for data imports.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_supported_locales_for_datasets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiSpeechtotextV30DatasetsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_supported_locales_for_datasets" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/locales', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSpeechtotextV30DatasetsLocalesGet200ApplicationJsonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_supported_locales_for_endpoints(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Endpoints  # noqa: E501

        Gets a list of supported locales for endpoint creations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_supported_locales_for_endpoints(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiSpeechtotextV30EndpointsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_supported_locales_for_endpoints_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_supported_locales_for_endpoints_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_supported_locales_for_endpoints_with_http_info(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Endpoints  # noqa: E501

        Gets a list of supported locales for endpoint creations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_supported_locales_for_endpoints_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiSpeechtotextV30EndpointsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_supported_locales_for_endpoints" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/locales', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSpeechtotextV30EndpointsLocalesGet200ApplicationJsonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_supported_locales_for_evaluations(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Evaluations  # noqa: E501

        Gets a list of supported locales for evaluations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_supported_locales_for_evaluations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiSpeechtotextV30EvaluationsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_supported_locales_for_evaluations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_supported_locales_for_evaluations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_supported_locales_for_evaluations_with_http_info(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Evaluations  # noqa: E501

        Gets a list of supported locales for evaluations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_supported_locales_for_evaluations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiSpeechtotextV30EvaluationsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_supported_locales_for_evaluations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/evaluations/locales', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSpeechtotextV30EvaluationsLocalesGet200ApplicationJsonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_supported_locales_for_models(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Models  # noqa: E501

        Gets a list of supported locales for model adaptation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_supported_locales_for_models(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiSpeechtotextV30ModelsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_supported_locales_for_models_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_supported_locales_for_models_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_supported_locales_for_models_with_http_info(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Models  # noqa: E501

        Gets a list of supported locales for model adaptation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_supported_locales_for_models_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiSpeechtotextV30ModelsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_supported_locales_for_models" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/models/locales', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSpeechtotextV30ModelsLocalesGet200ApplicationJsonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_supported_locales_for_transcriptions(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Transcriptions  # noqa: E501

        Gets a list of supported locales for offline transcriptions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_supported_locales_for_transcriptions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiSpeechtotextV30TranscriptionsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_supported_locales_for_transcriptions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_supported_locales_for_transcriptions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_supported_locales_for_transcriptions_with_http_info(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Transcriptions  # noqa: E501

        Gets a list of supported locales for offline transcriptions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_supported_locales_for_transcriptions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiSpeechtotextV30TranscriptionsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_supported_locales_for_transcriptions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/transcriptions/locales', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSpeechtotextV30TranscriptionsLocalesGet200ApplicationJsonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_supported_project_locales(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Projects  # noqa: E501

        Gets the list of supported locales.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_supported_project_locales(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiSpeechtotextV30ProjectsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_supported_project_locales_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_supported_project_locales_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_supported_project_locales_with_http_info(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Projects  # noqa: E501

        Gets the list of supported locales.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_supported_project_locales_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiSpeechtotextV30ProjectsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_supported_project_locales" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/projects/locales', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiSpeechtotextV30ProjectsLocalesGet200ApplicationJsonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transcription(self, id, **kwargs):  # noqa: E501
        """Get Transcription  # noqa: E501

        Gets the transcription identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transcription(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :return: Transcription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transcription_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transcription_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_transcription_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Transcription  # noqa: E501

        Gets the transcription identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transcription_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :return: Transcription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transcription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_transcription`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/transcriptions/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transcription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transcription_file(self, id, file_id, **kwargs):  # noqa: E501
        """Get Transcription File  # noqa: E501

        Gets one specific file (identified with fileId) from a transcription (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transcription_file(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transcription_file_with_http_info(id, file_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transcription_file_with_http_info(id, file_id, **kwargs)  # noqa: E501
            return data

    def get_transcription_file_with_http_info(self, id, file_id, **kwargs):  # noqa: E501
        """Get Transcription File  # noqa: E501

        Gets one specific file (identified with fileId) from a transcription (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transcription_file_with_http_info(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'file_id', 'sas_validity_in_seconds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transcription_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_transcription_file`")  # noqa: E501
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and ('file_id' not in params or
                                                       params['file_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `file_id` when calling `get_transcription_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'file_id' in params:
            path_params['fileId'] = params['file_id']  # noqa: E501

        query_params = []
        if 'sas_validity_in_seconds' in params:
            query_params.append(('sasValidityInSeconds', params['sas_validity_in_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/transcriptions/{id}/files/{fileId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='File',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transcription_files(self, id, **kwargs):  # noqa: E501
        """Get Transcription Files  # noqa: E501

        Gets the files of the transcription identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transcription_files(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :param int skip: Format - int32. Number of files that will be skipped.
        :param int top: Format - int32. Number of files that will be included after skipping.
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transcription_files_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transcription_files_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_transcription_files_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Transcription Files  # noqa: E501

        Gets the files of the transcription identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transcription_files_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.
        :param int skip: Format - int32. Number of files that will be skipped.
        :param int top: Format - int32. Number of files that will be included after skipping.
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sas_validity_in_seconds', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transcription_files" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_transcription_files`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sas_validity_in_seconds' in params:
            query_params.append(('sasValidityInSeconds', params['sas_validity_in_seconds']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/transcriptions/{id}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedFiles',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transcriptions(self, **kwargs):  # noqa: E501
        """Get Transcriptions  # noqa: E501

        Gets a list of transcriptions for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transcriptions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of transcriptions that will be skipped.
        :param int top: Format - int32. Number of transcriptions that will be included after skipping.
        :return: PaginatedTranscriptions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transcriptions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_transcriptions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_transcriptions_with_http_info(self, **kwargs):  # noqa: E501
        """Get Transcriptions  # noqa: E501

        Gets a list of transcriptions for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transcriptions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of transcriptions that will be skipped.
        :param int top: Format - int32. Number of transcriptions that will be included after skipping.
        :return: PaginatedTranscriptions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transcriptions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/transcriptions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedTranscriptions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transcriptions_for_project(self, id, **kwargs):  # noqa: E501
        """Get Transcriptions for Project  # noqa: E501

        Gets the list of transcriptions for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transcriptions_for_project(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of transcriptions that will be skipped.
        :param int top: Format - int32. Number of transcriptions that will be included after skipping.
        :return: PaginatedTranscriptions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transcriptions_for_project_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transcriptions_for_project_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_transcriptions_for_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Transcriptions for Project  # noqa: E501

        Gets the list of transcriptions for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transcriptions_for_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of transcriptions that will be skipped.
        :param int top: Format - int32. Number of transcriptions that will be included after skipping.
        :return: PaginatedTranscriptions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transcriptions_for_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_transcriptions_for_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}/transcriptions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedTranscriptions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ping_hook(self, id, **kwargs):  # noqa: E501
        """Ping Web Hook  # noqa: E501

        The request body of the POST request sent to the registered web hook URL is of the same shape as in the GET request for a specific hook.  The Swagger Schema ID of the model is WebHookV3.                The request will contain a X-MicrosoftSpeechServices-Event header with the value ping. If the web hook was registered with  a secret it will contain a X-MicrosoftSpeechServices-Signature header with an SHA256 hash of the payload with  the secret as HMAC key. The hash is base64 encoded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ping_hook(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook to ping. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ping_hook_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.ping_hook_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def ping_hook_with_http_info(self, id, **kwargs):  # noqa: E501
        """Ping Web Hook  # noqa: E501

        The request body of the POST request sent to the registered web hook URL is of the same shape as in the GET request for a specific hook.  The Swagger Schema ID of the model is WebHookV3.                The request will contain a X-MicrosoftSpeechServices-Event header with the value ping. If the web hook was registered with  a secret it will contain a X-MicrosoftSpeechServices-Signature header with an SHA256 hash of the payload with  the secret as HMAC key. The hash is base64 encoded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ping_hook_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook to ping. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ping_hook" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `ping_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/webhooks/{id}/ping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_hook(self, id, **kwargs):  # noqa: E501
        """Test Web Hook  # noqa: E501

        The payload will be generated from the last entity that would have invoked the web hook. If no entity is present for none of the registered event types,  the POST will respond with 204. If a test request can be made, it will respond with 200.  The request will contain a X-MicrosoftSpeechServices-Event header with the respective registered event type.  If the web hook was registered with a secret it will contain a X-MicrosoftSpeechServices-Signature header with an SHA256 hash of the payload with  the secret as HMAC key. The hash is base64 encoded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_hook(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook to ping. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_hook_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.test_hook_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def test_hook_with_http_info(self, id, **kwargs):  # noqa: E501
        """Test Web Hook  # noqa: E501

        The payload will be generated from the last entity that would have invoked the web hook. If no entity is present for none of the registered event types,  the POST will respond with 204. If a test request can be made, it will respond with 200.  The request will contain a X-MicrosoftSpeechServices-Event header with the respective registered event type.  If the web hook was registered with a secret it will contain a X-MicrosoftSpeechServices-Signature header with an SHA256 hash of the payload with  the secret as HMAC key. The hash is base64 encoded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_hook_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook to ping. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_hook" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `test_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/webhooks/{id}/test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dataset(self, id, **kwargs):  # noqa: E501
        """Update Dataset  # noqa: E501

        Updates the mutable details of the dataset identified by its ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dataset(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param DatasetUpdate dataset_update: The updated values for the dataset.
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dataset_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dataset_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_dataset_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Dataset  # noqa: E501

        Updates the mutable details of the dataset identified by its ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dataset_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param DatasetUpdate dataset_update: The updated values for the dataset.
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'dataset_update']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_dataset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dataset_update' in params:
            body_params = params['dataset_update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/merge-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Dataset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_endpoint(self, id, **kwargs):  # noqa: E501
        """Update Endpoint  # noqa: E501

        Updates the metadata of the endpoint identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_endpoint(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param EndpointUpdate endpoint_update: The updated values for the endpoint.
        :return: Endpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_endpoint_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_endpoint_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_endpoint_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Endpoint  # noqa: E501

        Updates the metadata of the endpoint identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_endpoint_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param EndpointUpdate endpoint_update: The updated values for the endpoint.
        :return: Endpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'endpoint_update']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'endpoint_update' in params:
            body_params = params['endpoint_update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/merge-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Endpoint',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_evaluation(self, id, **kwargs):  # noqa: E501
        """Update Evaluation  # noqa: E501

        Updates the mutable details of the evaluation identified by its id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_evaluation(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :param EvaluationUpdate evaluation_update: The object containing the updated fields of the evaluation.
        :return: Evaluation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_evaluation_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_evaluation_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_evaluation_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Evaluation  # noqa: E501

        Updates the mutable details of the evaluation identified by its id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_evaluation_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :param EvaluationUpdate evaluation_update: The object containing the updated fields of the evaluation.
        :return: Evaluation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'evaluation_update']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_evaluation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_evaluation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'evaluation_update' in params:
            body_params = params['evaluation_update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/merge-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/evaluations/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Evaluation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_hook(self, id, **kwargs):  # noqa: E501
        """Update Web Hook  # noqa: E501

        If the property secret in the configuration is omitted or contains an empty string, future callbacks won't contain X-MicrosoftSpeechServices-Signature  headers. If the property contains a non-empty string, it will be used to create a SHA256 hash of the payload with the secret as HMAC key. This hash  will be set as X-MicrosoftSpeechServices-Signature header when calling back into the registered URL.                If the URL changes,  the web hook will stop receiving events until a  challenge/response is completed. To do this, a request with the event type challenge will be made with a query parameter called validationToken.  Respond to the challenge with a 200 OK containing the value of the validationToken query parameter as the response body. When the challenge/response  is successfully completed, the web hook will begin receiving events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_hook(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook. (required)
        :param WebHookUpdate web_hook_update: The updated values for the web hook.
        :return: WebHook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_hook_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_hook_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_hook_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Web Hook  # noqa: E501

        If the property secret in the configuration is omitted or contains an empty string, future callbacks won't contain X-MicrosoftSpeechServices-Signature  headers. If the property contains a non-empty string, it will be used to create a SHA256 hash of the payload with the secret as HMAC key. This hash  will be set as X-MicrosoftSpeechServices-Signature header when calling back into the registered URL.                If the URL changes,  the web hook will stop receiving events until a  challenge/response is completed. To do this, a request with the event type challenge will be made with a query parameter called validationToken.  Respond to the challenge with a 200 OK containing the value of the validationToken query parameter as the response body. When the challenge/response  is successfully completed, the web hook will begin receiving events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_hook_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook. (required)
        :param WebHookUpdate web_hook_update: The updated values for the web hook.
        :return: WebHook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'web_hook_update']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_hook" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_hook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_hook_update' in params:
            body_params = params['web_hook_update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/merge-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/webhooks/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WebHook',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_model(self, id, **kwargs):  # noqa: E501
        """Update Model  # noqa: E501

        Updates the metadata of the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :param ModelUpdate model_update: The updated values for the model.
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_model_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_model_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_model_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Model  # noqa: E501

        Updates the metadata of the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :param ModelUpdate model_update: The updated values for the model.
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'model_update']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_update' in params:
            body_params = params['model_update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/merge-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/models/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Model',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_project(self, id, **kwargs):  # noqa: E501
        """Update Project  # noqa: E501

        Updates the project identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_project(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param ProjectUpdate project_update: The updated values for the project.
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_project_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_project_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Project  # noqa: E501

        Updates the project identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param ProjectUpdate project_update: The updated values for the project.
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'project_update']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_update' in params:
            body_params = params['project_update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/merge-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Project',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transcription(self, id, **kwargs):  # noqa: E501
        """Update Transcription  # noqa: E501

        Updates the mutable details of the transcription identified by its ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_transcription(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :param TranscriptionUpdate transcription_update: The updated values for the transcription.
        :return: Transcription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_transcription_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transcription_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_transcription_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Transcription  # noqa: E501

        Updates the mutable details of the transcription identified by its ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_transcription_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :param TranscriptionUpdate transcription_update: The updated values for the transcription.
        :return: Transcription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'transcription_update']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transcription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `update_transcription`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transcription_update' in params:
            body_params = params['transcription_update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/merge-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/transcriptions/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transcription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_dataset_from_form(self, **kwargs):  # noqa: E501
        """Create Dataset from Form  # noqa: E501

        Uploads data and creates a new dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_dataset_from_form(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project: The optional string representation of the url of a project. If set, the dataset will be associated with that project.
        :param str display_name: The name of this data import (required).
        :param str description: Optional description of this data import.
        :param str locale: The locale of this data import (required).
        :param str kind: The kind of the data import (required).
        :param str custom_properties: The optional custom properties of this entity. The maximum allowed key length is 64 characters, the maximum allowed value length is 256 characters and the count of allowed entries is 10.
        :param file data: For acoustic data imports, a zip file containing the audio data and a text file containing the transcriptions for the audio data. for language data imports, a text file containing the language or pronunciation data. Required in both cases.
        :param str email: An optional string containing the email address to send email notifications to in case the operation completes. The value will be removed after successfully sending the email.
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_dataset_from_form_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.upload_dataset_from_form_with_http_info(**kwargs)  # noqa: E501
            return data

    def upload_dataset_from_form_with_http_info(self, **kwargs):  # noqa: E501
        """Create Dataset from Form  # noqa: E501

        Uploads data and creates a new dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_dataset_from_form_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project: The optional string representation of the url of a project. If set, the dataset will be associated with that project.
        :param str display_name: The name of this data import (required).
        :param str description: Optional description of this data import.
        :param str locale: The locale of this data import (required).
        :param str kind: The kind of the data import (required).
        :param str custom_properties: The optional custom properties of this entity. The maximum allowed key length is 64 characters, the maximum allowed value length is 256 characters and the count of allowed entries is 10.
        :param file data: For acoustic data imports, a zip file containing the audio data and a text file containing the transcriptions for the audio data. for language data imports, a text file containing the language or pronunciation data. Required in both cases.
        :param str email: An optional string containing the email address to send email notifications to in case the operation completes. The value will be removed after successfully sending the email.
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'display_name', 'description', 'locale', 'kind', 'custom_properties', 'data', 'email']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_dataset_from_form" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'project' in params:
            form_params.append(('project', params['project']))  # noqa: E501
        if 'display_name' in params:
            form_params.append(('displayName', params['display_name']))  # noqa: E501
        if 'description' in params:
            form_params.append(('description', params['description']))  # noqa: E501
        if 'locale' in params:
            form_params.append(('locale', params['locale']))  # noqa: E501
        if 'kind' in params:
            form_params.append(('kind', params['kind']))  # noqa: E501
        if 'custom_properties' in params:
            form_params.append(('customProperties', params['custom_properties']))  # noqa: E501
        if 'data' in params:
            local_var_files['data'] = params['data']  # noqa: E501
        if 'email' in params:
            form_params.append(('email', params['email']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Dataset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
